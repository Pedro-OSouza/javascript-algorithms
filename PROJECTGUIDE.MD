# üöÄ Roadmap de Algoritmos e Estruturas de Dados

Este guia detalha os algoritmos fundamentais organizados por n√≠vel de complexidade e categoria.

---

## 1. Fundamentos (Obrigat√≥rios)
*Esses formam o ‚Äúalfabeto‚Äù do pensamento algor√≠tmico.*

### Sequenciais e controle
- Soma, m√©dia, m√°ximo e m√≠nimo
- Contador e acumulador
- Troca de valores (`swap`)
- La√ßos `for`, `while`, `do-while`
- Condicionais encadeadas
- Algoritmo de contagem de ocorr√™ncias
- Verifica√ß√£o de paridade
- Fatorial (iterativo e recursivo)
- Pot√™ncia (iterativa e recursiva)

### Recurs√£o b√°sica
- Fatorial recursivo
- Fibonacci (recursivo e otimizado)
- Soma de elementos recursiva
- Torre de Hanoi
- Percurso simples recursivo em array

---

## 2. Algoritmos de Busca
*Essenciais para efici√™ncia e estrutura√ß√£o de dados.*

- Busca linear
- Busca bin√°ria (iterativa e recursiva)
- Busca tern√°ria
- Busca em profundidade (DFS)
- Busca em largura (BFS)

---

## 3. Algoritmos de Ordena√ß√£o
*Cl√°ssicos e obrigat√≥rios em entrevistas e provas.*

### Simples
- Bubble Sort
- Selection Sort
- Insertion Sort

### Intermedi√°rios
- Merge Sort
- Quick Sort
- Heap Sort
- Shell Sort

### Espec√≠ficos
- Counting Sort
- Radix Sort
- Bucket Sort

---

## 4. Estruturas de Dados (com algoritmos)
*N√£o basta usar: √© importante saber implementar.*

### Lineares
- Array din√¢mico
- Lista ligada (simples, dupla, circular)
- Pilha
- Fila
- Fila circular
- Deque

### N√£o lineares
- √Årvore bin√°ria
- √Årvore bin√°ria de busca (BST)
- AVL
- Red-Black Tree
- Trie
- Heap (min e max)

### Hash
- Tabela hash
- Hash com encadeamento
- Hash com endere√ßamento aberto

---

## 5. Algoritmos em Grafos
*Muito importantes em problemas reais e acad√™micos.*

### Percurso
- BFS (Breadth-First Search)
- DFS (Depth-First Search)

### Caminho m√≠nimo
- Dijkstra
- Bellman-Ford
- Floyd-Warshall

### √Årvore geradora m√≠nima
- Kruskal
- Prim

### Outros
- Ordena√ß√£o topol√≥gica
- Detec√ß√£o de ciclos
- Componentes conexos
- Union-Find (Disjoint Set)

---

## 6. Programa√ß√£o Din√¢mica
*Aqui entra maturidade algor√≠tmica.*

- Fibonacci com memoization
- Problema da mochila (0/1)
- Subsequ√™ncia comum mais longa (LCS)
- Substring comum mais longa
- Corte de hastes
- Caminho m√≠nimo em grid
- Coin Change
- Edit Distance (Levenshtein)

---

## 7. Algoritmos Matem√°ticos
*Base para jogos, criptografia e otimiza√ß√µes.*

- M√°ximo divisor comum (Euclides)
- M√≠nimo m√∫ltiplo comum
- Crivo de Erat√≥stenes
- Verifica√ß√£o de n√∫mero primo
- Exponencia√ß√£o r√°pida
- Fatorial grande
- Convers√£o de base num√©rica
- Opera√ß√µes com matrizes
- Algoritmo de Newton-Raphson

---

## 8. Algoritmos de Strings
*Muito usados em back-end e parsing.*

- Pal√≠ndromo
- Contagem de caracteres
- Anagramas
- Busca de padr√£o ing√™nua
- KMP (Knuth-Morris-Pratt)
- Rabin-Karp
- Boyer-Moore
- Longest Prefix Suffix (LPS)
- Compress√£o RLE (Run-Length Encoding)

---

## 9. Algoritmos Gulosos (Greedy)
*Simples, mas conceitualmente importantes.*

- Troco m√≠nimo
- Sele√ß√£o de atividades
- Huffman Coding
- Kruskal (tamb√©m entra aqui)
- Prim (tamb√©m entra aqui)

---

## 10. Algoritmos Cl√°ssicos ‚Äúde respeito‚Äù
*Esses elevam o n√≠vel do reposit√≥rio.*

- Backtracking (N-Queens, Sudoku)
- Divide and Conquer
- Two Pointers
- Sliding Window
- Kadane (subarray m√°ximo)
- Algoritmo de Kadane 2D
- Bit Manipulation b√°sico
- Flood Fill

---

## 11. Complexidade e An√°lise
*N√£o √© c√≥digo, mas deve estar documentado.*

- Nota√ß√£o Big O, $\Omega$ e $\Theta$
- An√°lise de tempo e espa√ßo
- Compara√ß√£o emp√≠rica de algoritmos
- Casos melhor, m√©dio e pior